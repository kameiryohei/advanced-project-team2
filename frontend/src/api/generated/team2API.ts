/**
 * Generated by orval v7.13.2 ğŸº
 * Do not edit manually.
 * å…ˆé€²ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå®Ÿé¨“ Team2 é¿é›£æ‰€ API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateCommentRequest,
  CreateCommentResponse,
  CreatePostResponse,
  ErrorResponse,
  GetApiGeocodeReverseParams,
  GetApiSyncLogsParams,
  GetPostsIdCommentsParams,
  PostCommentsResponse,
  PostDetailResponse,
  PostPostsBody,
  ReverseGeocoderResponse,
  ShelterDetails,
  ShelterListWithCountResponse,
  ShelterPostsResponse,
  SyncExecuteRequest,
  SyncExecuteResponse,
  SyncLogsResponse,
  SyncMediaExecuteRequest,
  SyncMediaReceiveRequest,
  SyncMediaReceiveResponse,
  SyncMediaResponse,
  SyncReceiveRequest,
  SyncReceiveResponse,
  SyncStatusResponse
} from './model';

import { axiosInstance } from '../axios-instance';
import type { ErrorType } from '../axios-instance';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Yahoo!åœ°å›³APIã®é€†ã‚¸ã‚ªã‚³ãƒ¼ãƒ€ã‚’å‘¼ã³å‡ºã—ã€ä½æ‰€ã¨è£œåŠ©æƒ…å ±ã‚’è¿”ã—ã¾ã™ã€‚
 * @summary ç·¯åº¦ãƒ»çµŒåº¦ã‹ã‚‰ä½æ‰€ã‚’å–å¾—
 */
export const getApiGeocodeReverse = (
    params: GetApiGeocodeReverseParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<ReverseGeocoderResponse>(
      {url: `/api/geocode/reverse`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetApiGeocodeReverseQueryKey = (params?: GetApiGeocodeReverseParams,) => {
    return [
    `/api/geocode/reverse`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetApiGeocodeReverseQueryOptions = <TData = Awaited<ReturnType<typeof getApiGeocodeReverse>>, TError = ErrorType<ErrorResponse | ErrorResponse | ErrorResponse>>(params: GetApiGeocodeReverseParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiGeocodeReverse>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiGeocodeReverseQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiGeocodeReverse>>> = ({ signal }) => getApiGeocodeReverse(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiGeocodeReverse>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiGeocodeReverseQueryResult = NonNullable<Awaited<ReturnType<typeof getApiGeocodeReverse>>>
export type GetApiGeocodeReverseQueryError = ErrorType<ErrorResponse | ErrorResponse | ErrorResponse>


export function useGetApiGeocodeReverse<TData = Awaited<ReturnType<typeof getApiGeocodeReverse>>, TError = ErrorType<ErrorResponse | ErrorResponse | ErrorResponse>>(
 params: GetApiGeocodeReverseParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiGeocodeReverse>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiGeocodeReverse>>,
          TError,
          Awaited<ReturnType<typeof getApiGeocodeReverse>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiGeocodeReverse<TData = Awaited<ReturnType<typeof getApiGeocodeReverse>>, TError = ErrorType<ErrorResponse | ErrorResponse | ErrorResponse>>(
 params: GetApiGeocodeReverseParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiGeocodeReverse>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiGeocodeReverse>>,
          TError,
          Awaited<ReturnType<typeof getApiGeocodeReverse>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiGeocodeReverse<TData = Awaited<ReturnType<typeof getApiGeocodeReverse>>, TError = ErrorType<ErrorResponse | ErrorResponse | ErrorResponse>>(
 params: GetApiGeocodeReverseParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiGeocodeReverse>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ç·¯åº¦ãƒ»çµŒåº¦ã‹ã‚‰ä½æ‰€ã‚’å–å¾—
 */

export function useGetApiGeocodeReverse<TData = Awaited<ReturnType<typeof getApiGeocodeReverse>>, TError = ErrorType<ErrorResponse | ErrorResponse | ErrorResponse>>(
 params: GetApiGeocodeReverseParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiGeocodeReverse>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiGeocodeReverseQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * æœªåŒæœŸãƒ‡ãƒ¼ã‚¿ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾—ã—ã¾ã™ã€‚
 * @summary åŒæœŸã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
 */
export const getApiSyncStatus = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<SyncStatusResponse>(
      {url: `/api/sync/status`, method: 'GET', signal
    },
      options);
    }
  



export const getGetApiSyncStatusQueryKey = () => {
    return [
    `/api/sync/status`
    ] as const;
    }

    
export const getGetApiSyncStatusQueryOptions = <TData = Awaited<ReturnType<typeof getApiSyncStatus>>, TError = ErrorType<ErrorResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSyncStatus>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiSyncStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiSyncStatus>>> = ({ signal }) => getApiSyncStatus(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiSyncStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiSyncStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getApiSyncStatus>>>
export type GetApiSyncStatusQueryError = ErrorType<ErrorResponse>


export function useGetApiSyncStatus<TData = Awaited<ReturnType<typeof getApiSyncStatus>>, TError = ErrorType<ErrorResponse>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSyncStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiSyncStatus>>,
          TError,
          Awaited<ReturnType<typeof getApiSyncStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiSyncStatus<TData = Awaited<ReturnType<typeof getApiSyncStatus>>, TError = ErrorType<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSyncStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiSyncStatus>>,
          TError,
          Awaited<ReturnType<typeof getApiSyncStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiSyncStatus<TData = Awaited<ReturnType<typeof getApiSyncStatus>>, TError = ErrorType<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSyncStatus>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary åŒæœŸã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å–å¾—
 */

export function useGetApiSyncStatus<TData = Awaited<ReturnType<typeof getApiSyncStatus>>, TError = ErrorType<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSyncStatus>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiSyncStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * ãƒ­ãƒ¼ã‚«ãƒ«DBã®æœªåŒæœŸãƒ‡ãƒ¼ã‚¿ã‚’æœ¬ç•ªDBã«åŒæœŸã—ã¾ã™ã€‚
 * @summary åŒæœŸã‚’å®Ÿè¡Œ
 */
export const postApiSyncExecute = (
    syncExecuteRequest: SyncExecuteRequest,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<SyncExecuteResponse>(
      {url: `/api/sync/execute`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: syncExecuteRequest, signal
    },
      options);
    }
  


export const getPostApiSyncExecuteMutationOptions = <TError = ErrorType<ErrorResponse | ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiSyncExecute>>, TError,{data: SyncExecuteRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiSyncExecute>>, TError,{data: SyncExecuteRequest}, TContext> => {

const mutationKey = ['postApiSyncExecute'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiSyncExecute>>, {data: SyncExecuteRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiSyncExecute(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiSyncExecuteMutationResult = NonNullable<Awaited<ReturnType<typeof postApiSyncExecute>>>
    export type PostApiSyncExecuteMutationBody = SyncExecuteRequest
    export type PostApiSyncExecuteMutationError = ErrorType<ErrorResponse | ErrorResponse>

    /**
 * @summary åŒæœŸã‚’å®Ÿè¡Œ
 */
export const usePostApiSyncExecute = <TError = ErrorType<ErrorResponse | ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiSyncExecute>>, TError,{data: SyncExecuteRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiSyncExecute>>,
        TError,
        {data: SyncExecuteRequest},
        TContext
      > => {

      const mutationOptions = getPostApiSyncExecuteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ãƒ­ãƒ¼ã‚«ãƒ«R2ã®æœªåŒæœŸãƒ¡ãƒ‡ã‚£ã‚¢ã‚’æœ¬ç•ªR2ã«åŒæœŸã—ã¾ã™ã€‚
 * @summary ãƒ¡ãƒ‡ã‚£ã‚¢åŒæœŸã‚’å®Ÿè¡Œ
 */
export const postApiSyncMedia = (
    syncMediaExecuteRequest: SyncMediaExecuteRequest,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<SyncMediaResponse>(
      {url: `/api/sync/media`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: syncMediaExecuteRequest, signal
    },
      options);
    }
  


export const getPostApiSyncMediaMutationOptions = <TError = ErrorType<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiSyncMedia>>, TError,{data: SyncMediaExecuteRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiSyncMedia>>, TError,{data: SyncMediaExecuteRequest}, TContext> => {

const mutationKey = ['postApiSyncMedia'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiSyncMedia>>, {data: SyncMediaExecuteRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiSyncMedia(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiSyncMediaMutationResult = NonNullable<Awaited<ReturnType<typeof postApiSyncMedia>>>
    export type PostApiSyncMediaMutationBody = SyncMediaExecuteRequest
    export type PostApiSyncMediaMutationError = ErrorType<ErrorResponse>

    /**
 * @summary ãƒ¡ãƒ‡ã‚£ã‚¢åŒæœŸã‚’å®Ÿè¡Œ
 */
export const usePostApiSyncMedia = <TError = ErrorType<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiSyncMedia>>, TError,{data: SyncMediaExecuteRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiSyncMedia>>,
        TError,
        {data: SyncMediaExecuteRequest},
        TContext
      > => {

      const mutationOptions = getPostApiSyncMediaMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æœ¬ç•ªå´ã§ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å—ä¿¡ã—ã¦R2ã«ä¿å­˜ã—ã¾ã™ã€‚
 * @summary ãƒ¡ãƒ‡ã‚£ã‚¢åŒæœŸãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡
 */
export const postApiSyncMediaReceive = (
    syncMediaReceiveRequest: SyncMediaReceiveRequest,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`filePath`, syncMediaReceiveRequest.filePath)
if(syncMediaReceiveRequest.contentType !== undefined) {
 formData.append(`contentType`, syncMediaReceiveRequest.contentType)
 }
formData.append(`file`, syncMediaReceiveRequest.file)

      return axiosInstance<SyncMediaReceiveResponse>(
      {url: `/api/sync/media/receive`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getPostApiSyncMediaReceiveMutationOptions = <TError = ErrorType<ErrorResponse | ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiSyncMediaReceive>>, TError,{data: SyncMediaReceiveRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiSyncMediaReceive>>, TError,{data: SyncMediaReceiveRequest}, TContext> => {

const mutationKey = ['postApiSyncMediaReceive'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiSyncMediaReceive>>, {data: SyncMediaReceiveRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiSyncMediaReceive(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiSyncMediaReceiveMutationResult = NonNullable<Awaited<ReturnType<typeof postApiSyncMediaReceive>>>
    export type PostApiSyncMediaReceiveMutationBody = SyncMediaReceiveRequest
    export type PostApiSyncMediaReceiveMutationError = ErrorType<ErrorResponse | ErrorResponse>

    /**
 * @summary ãƒ¡ãƒ‡ã‚£ã‚¢åŒæœŸãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡
 */
export const usePostApiSyncMediaReceive = <TError = ErrorType<ErrorResponse | ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiSyncMediaReceive>>, TError,{data: SyncMediaReceiveRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiSyncMediaReceive>>,
        TError,
        {data: SyncMediaReceiveRequest},
        TContext
      > => {

      const mutationOptions = getPostApiSyncMediaReceiveMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * ä»–ã®ç’°å¢ƒã‹ã‚‰ã®åŒæœŸãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡ã—ã¦DBã«ä¿å­˜ã—ã¾ã™ã€‚
 * @summary åŒæœŸãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡
 */
export const postApiSyncReceive = (
    syncReceiveRequest: SyncReceiveRequest,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<SyncReceiveResponse>(
      {url: `/api/sync/receive`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: syncReceiveRequest, signal
    },
      options);
    }
  


export const getPostApiSyncReceiveMutationOptions = <TError = ErrorType<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiSyncReceive>>, TError,{data: SyncReceiveRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postApiSyncReceive>>, TError,{data: SyncReceiveRequest}, TContext> => {

const mutationKey = ['postApiSyncReceive'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiSyncReceive>>, {data: SyncReceiveRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiSyncReceive(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiSyncReceiveMutationResult = NonNullable<Awaited<ReturnType<typeof postApiSyncReceive>>>
    export type PostApiSyncReceiveMutationBody = SyncReceiveRequest
    export type PostApiSyncReceiveMutationError = ErrorType<ErrorResponse>

    /**
 * @summary åŒæœŸãƒ‡ãƒ¼ã‚¿ã‚’å—ä¿¡
 */
export const usePostApiSyncReceive = <TError = ErrorType<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiSyncReceive>>, TError,{data: SyncReceiveRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiSyncReceive>>,
        TError,
        {data: SyncReceiveRequest},
        TContext
      > => {

      const mutationOptions = getPostApiSyncReceiveMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * éå»ã®åŒæœŸå±¥æ­´ã‚’ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³å½¢å¼ã§å–å¾—ã—ã¾ã™ã€‚
 * @summary åŒæœŸãƒ­ã‚°ä¸€è¦§ã‚’å–å¾—
 */
export const getApiSyncLogs = (
    params?: GetApiSyncLogsParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<SyncLogsResponse>(
      {url: `/api/sync/logs`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetApiSyncLogsQueryKey = (params?: GetApiSyncLogsParams,) => {
    return [
    `/api/sync/logs`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetApiSyncLogsQueryOptions = <TData = Awaited<ReturnType<typeof getApiSyncLogs>>, TError = ErrorType<ErrorResponse>>(params?: GetApiSyncLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSyncLogs>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiSyncLogsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiSyncLogs>>> = ({ signal }) => getApiSyncLogs(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiSyncLogs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiSyncLogsQueryResult = NonNullable<Awaited<ReturnType<typeof getApiSyncLogs>>>
export type GetApiSyncLogsQueryError = ErrorType<ErrorResponse>


export function useGetApiSyncLogs<TData = Awaited<ReturnType<typeof getApiSyncLogs>>, TError = ErrorType<ErrorResponse>>(
 params: undefined |  GetApiSyncLogsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSyncLogs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiSyncLogs>>,
          TError,
          Awaited<ReturnType<typeof getApiSyncLogs>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiSyncLogs<TData = Awaited<ReturnType<typeof getApiSyncLogs>>, TError = ErrorType<ErrorResponse>>(
 params?: GetApiSyncLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSyncLogs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiSyncLogs>>,
          TError,
          Awaited<ReturnType<typeof getApiSyncLogs>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiSyncLogs<TData = Awaited<ReturnType<typeof getApiSyncLogs>>, TError = ErrorType<ErrorResponse>>(
 params?: GetApiSyncLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSyncLogs>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary åŒæœŸãƒ­ã‚°ä¸€è¦§ã‚’å–å¾—
 */

export function useGetApiSyncLogs<TData = Awaited<ReturnType<typeof getApiSyncLogs>>, TError = ErrorType<ErrorResponse>>(
 params?: GetApiSyncLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiSyncLogs>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiSyncLogsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * æœ¬æ–‡ãƒ»æ™‚åˆ»ãƒ»ä½ç½®ãƒˆãƒ©ãƒƒã‚¯ãªã©ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¨ã€ç”»åƒ/å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åŒæ¢±ã—ã¦æŠ•ç¨¿ã—ã¾ã™ã€‚
 * @summary æŠ•ç¨¿ã‚’æ–°è¦ä½œæˆï¼ˆãƒ¡ãƒ‡ã‚£ã‚¢åŒæ¢±ï¼‰
 */
export const postPosts = (
    postPostsBody: PostPostsBody,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`metadata`, JSON.stringify(postPostsBody.metadata));
if(postPostsBody.mediaFiles !== undefined) {
 postPostsBody.mediaFiles.forEach(value => formData.append(`mediaFiles`, value));
 }

      return axiosInstance<CreatePostResponse>(
      {url: `/posts`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getPostPostsMutationOptions = <TError = ErrorType<ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPosts>>, TError,{data: PostPostsBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postPosts>>, TError,{data: PostPostsBody}, TContext> => {

const mutationKey = ['postPosts'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postPosts>>, {data: PostPostsBody}> = (props) => {
          const {data} = props ?? {};

          return  postPosts(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostPostsMutationResult = NonNullable<Awaited<ReturnType<typeof postPosts>>>
    export type PostPostsMutationBody = PostPostsBody
    export type PostPostsMutationError = ErrorType<ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse>

    /**
 * @summary æŠ•ç¨¿ã‚’æ–°è¦ä½œæˆï¼ˆãƒ¡ãƒ‡ã‚£ã‚¢åŒæ¢±ï¼‰
 */
export const usePostPosts = <TError = ErrorType<ErrorResponse | ErrorResponse | ErrorResponse | ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPosts>>, TError,{data: PostPostsBody}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postPosts>>,
        TError,
        {data: PostPostsBody},
        TContext
      > => {

      const mutationOptions = getPostPostsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * æŒ‡å®šã—ãŸæŠ•ç¨¿IDã®è©³ç´°æƒ…å ±ï¼ˆãƒ¡ãƒ‡ã‚£ã‚¢URLå«ã‚€ï¼‰ã‚’å–å¾—ã—ã¾ã™ã€‚
 * @summary æŠ•ç¨¿ã®è©³ç´°ã‚’å–å¾—
 */
export const getPostsId = (
    id: string,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PostDetailResponse>(
      {url: `/posts/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetPostsIdQueryKey = (id?: string,) => {
    return [
    `/posts/${id}`
    ] as const;
    }

    
export const getGetPostsIdQueryOptions = <TData = Awaited<ReturnType<typeof getPostsId>>, TError = ErrorType<ErrorResponse | ErrorResponse>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsId>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPostsIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPostsId>>> = ({ signal }) => getPostsId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPostsId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPostsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPostsId>>>
export type GetPostsIdQueryError = ErrorType<ErrorResponse | ErrorResponse>


export function useGetPostsId<TData = Awaited<ReturnType<typeof getPostsId>>, TError = ErrorType<ErrorResponse | ErrorResponse>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPostsId>>,
          TError,
          Awaited<ReturnType<typeof getPostsId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPostsId<TData = Awaited<ReturnType<typeof getPostsId>>, TError = ErrorType<ErrorResponse | ErrorResponse>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPostsId>>,
          TError,
          Awaited<ReturnType<typeof getPostsId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPostsId<TData = Awaited<ReturnType<typeof getPostsId>>, TError = ErrorType<ErrorResponse | ErrorResponse>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsId>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æŠ•ç¨¿ã®è©³ç´°ã‚’å–å¾—
 */

export function useGetPostsId<TData = Awaited<ReturnType<typeof getPostsId>>, TError = ErrorType<ErrorResponse | ErrorResponse>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsId>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPostsIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary é¿é›£æ‰€ä¸€è¦§ã‚’å–å¾—
 */
export const getShelters = (
    
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<ShelterListWithCountResponse>(
      {url: `/shelters`, method: 'GET', signal
    },
      options);
    }
  



export const getGetSheltersQueryKey = () => {
    return [
    `/shelters`
    ] as const;
    }

    
export const getGetSheltersQueryOptions = <TData = Awaited<ReturnType<typeof getShelters>>, TError = ErrorType<ErrorResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelters>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSheltersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getShelters>>> = ({ signal }) => getShelters(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getShelters>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSheltersQueryResult = NonNullable<Awaited<ReturnType<typeof getShelters>>>
export type GetSheltersQueryError = ErrorType<ErrorResponse>


export function useGetShelters<TData = Awaited<ReturnType<typeof getShelters>>, TError = ErrorType<ErrorResponse>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelters>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getShelters>>,
          TError,
          Awaited<ReturnType<typeof getShelters>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetShelters<TData = Awaited<ReturnType<typeof getShelters>>, TError = ErrorType<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelters>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getShelters>>,
          TError,
          Awaited<ReturnType<typeof getShelters>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetShelters<TData = Awaited<ReturnType<typeof getShelters>>, TError = ErrorType<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelters>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary é¿é›£æ‰€ä¸€è¦§ã‚’å–å¾—
 */

export function useGetShelters<TData = Awaited<ReturnType<typeof getShelters>>, TError = ErrorType<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getShelters>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSheltersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary é¿é›£æ‰€ã®è©³ç´°ã‚’å–å¾—
 */
export const getSheltersId = (
    id: number,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<ShelterDetails>(
      {url: `/shelters/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetSheltersIdQueryKey = (id?: number,) => {
    return [
    `/shelters/${id}`
    ] as const;
    }

    
export const getGetSheltersIdQueryOptions = <TData = Awaited<ReturnType<typeof getSheltersId>>, TError = ErrorType<ErrorResponse | ErrorResponse | void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSheltersId>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSheltersIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSheltersId>>> = ({ signal }) => getSheltersId(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSheltersId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSheltersIdQueryResult = NonNullable<Awaited<ReturnType<typeof getSheltersId>>>
export type GetSheltersIdQueryError = ErrorType<ErrorResponse | ErrorResponse | void>


export function useGetSheltersId<TData = Awaited<ReturnType<typeof getSheltersId>>, TError = ErrorType<ErrorResponse | ErrorResponse | void>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSheltersId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSheltersId>>,
          TError,
          Awaited<ReturnType<typeof getSheltersId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSheltersId<TData = Awaited<ReturnType<typeof getSheltersId>>, TError = ErrorType<ErrorResponse | ErrorResponse | void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSheltersId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSheltersId>>,
          TError,
          Awaited<ReturnType<typeof getSheltersId>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSheltersId<TData = Awaited<ReturnType<typeof getSheltersId>>, TError = ErrorType<ErrorResponse | ErrorResponse | void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSheltersId>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary é¿é›£æ‰€ã®è©³ç´°ã‚’å–å¾—
 */

export function useGetSheltersId<TData = Awaited<ReturnType<typeof getSheltersId>>, TError = ErrorType<ErrorResponse | ErrorResponse | void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSheltersId>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSheltersIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary æŒ‡å®šã—ãŸé¿é›£æ‰€ã®æœ€æ–°æŠ•ç¨¿ã‚’å–å¾—
 */
export const getSheltersIdPosts = (
    id: number,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<ShelterPostsResponse>(
      {url: `/shelters/${id}/posts`, method: 'GET', signal
    },
      options);
    }
  



export const getGetSheltersIdPostsQueryKey = (id?: number,) => {
    return [
    `/shelters/${id}/posts`
    ] as const;
    }

    
export const getGetSheltersIdPostsQueryOptions = <TData = Awaited<ReturnType<typeof getSheltersIdPosts>>, TError = ErrorType<ErrorResponse | ErrorResponse>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSheltersIdPosts>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSheltersIdPostsQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSheltersIdPosts>>> = ({ signal }) => getSheltersIdPosts(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSheltersIdPosts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSheltersIdPostsQueryResult = NonNullable<Awaited<ReturnType<typeof getSheltersIdPosts>>>
export type GetSheltersIdPostsQueryError = ErrorType<ErrorResponse | ErrorResponse>


export function useGetSheltersIdPosts<TData = Awaited<ReturnType<typeof getSheltersIdPosts>>, TError = ErrorType<ErrorResponse | ErrorResponse>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSheltersIdPosts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSheltersIdPosts>>,
          TError,
          Awaited<ReturnType<typeof getSheltersIdPosts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSheltersIdPosts<TData = Awaited<ReturnType<typeof getSheltersIdPosts>>, TError = ErrorType<ErrorResponse | ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSheltersIdPosts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSheltersIdPosts>>,
          TError,
          Awaited<ReturnType<typeof getSheltersIdPosts>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSheltersIdPosts<TData = Awaited<ReturnType<typeof getSheltersIdPosts>>, TError = ErrorType<ErrorResponse | ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSheltersIdPosts>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æŒ‡å®šã—ãŸé¿é›£æ‰€ã®æœ€æ–°æŠ•ç¨¿ã‚’å–å¾—
 */

export function useGetSheltersIdPosts<TData = Awaited<ReturnType<typeof getSheltersIdPosts>>, TError = ErrorType<ErrorResponse | ErrorResponse>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSheltersIdPosts>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSheltersIdPostsQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary æŠ•ç¨¿ã«ç´ã¥ãã‚³ãƒ¡ãƒ³ãƒˆä¸€è¦§ã‚’å–å¾—
 */
export const getPostsIdComments = (
    id: string,
    params?: GetPostsIdCommentsParams,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<PostCommentsResponse>(
      {url: `/posts/${id}/comments`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetPostsIdCommentsQueryKey = (id?: string,
    params?: GetPostsIdCommentsParams,) => {
    return [
    `/posts/${id}/comments`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetPostsIdCommentsQueryOptions = <TData = Awaited<ReturnType<typeof getPostsIdComments>>, TError = ErrorType<ErrorResponse | ErrorResponse>>(id: string,
    params?: GetPostsIdCommentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsIdComments>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPostsIdCommentsQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPostsIdComments>>> = ({ signal }) => getPostsIdComments(id,params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPostsIdComments>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPostsIdCommentsQueryResult = NonNullable<Awaited<ReturnType<typeof getPostsIdComments>>>
export type GetPostsIdCommentsQueryError = ErrorType<ErrorResponse | ErrorResponse>


export function useGetPostsIdComments<TData = Awaited<ReturnType<typeof getPostsIdComments>>, TError = ErrorType<ErrorResponse | ErrorResponse>>(
 id: string,
    params: undefined |  GetPostsIdCommentsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsIdComments>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPostsIdComments>>,
          TError,
          Awaited<ReturnType<typeof getPostsIdComments>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPostsIdComments<TData = Awaited<ReturnType<typeof getPostsIdComments>>, TError = ErrorType<ErrorResponse | ErrorResponse>>(
 id: string,
    params?: GetPostsIdCommentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsIdComments>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPostsIdComments>>,
          TError,
          Awaited<ReturnType<typeof getPostsIdComments>>
        > , 'initialData'
      >, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPostsIdComments<TData = Awaited<ReturnType<typeof getPostsIdComments>>, TError = ErrorType<ErrorResponse | ErrorResponse>>(
 id: string,
    params?: GetPostsIdCommentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsIdComments>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary æŠ•ç¨¿ã«ç´ã¥ãã‚³ãƒ¡ãƒ³ãƒˆä¸€è¦§ã‚’å–å¾—
 */

export function useGetPostsIdComments<TData = Awaited<ReturnType<typeof getPostsIdComments>>, TError = ErrorType<ErrorResponse | ErrorResponse>>(
 id: string,
    params?: GetPostsIdCommentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostsIdComments>>, TError, TData>>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPostsIdCommentsQueryOptions(id,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary ã‚³ãƒ¡ãƒ³ãƒˆã‚’æ–°è¦æŠ•ç¨¿
 */
export const postPostsIdComments = (
    id: string,
    createCommentRequest: CreateCommentRequest,
 options?: SecondParameter<typeof axiosInstance>,signal?: AbortSignal
) => {
      
      
      return axiosInstance<CreateCommentResponse>(
      {url: `/posts/${id}/comments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createCommentRequest, signal
    },
      options);
    }
  


export const getPostPostsIdCommentsMutationOptions = <TError = ErrorType<ErrorResponse | ErrorResponse | ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPostsIdComments>>, TError,{id: string;data: CreateCommentRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof postPostsIdComments>>, TError,{id: string;data: CreateCommentRequest}, TContext> => {

const mutationKey = ['postPostsIdComments'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postPostsIdComments>>, {id: string;data: CreateCommentRequest}> = (props) => {
          const {id,data} = props ?? {};

          return  postPostsIdComments(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostPostsIdCommentsMutationResult = NonNullable<Awaited<ReturnType<typeof postPostsIdComments>>>
    export type PostPostsIdCommentsMutationBody = CreateCommentRequest
    export type PostPostsIdCommentsMutationError = ErrorType<ErrorResponse | ErrorResponse | ErrorResponse>

    /**
 * @summary ã‚³ãƒ¡ãƒ³ãƒˆã‚’æ–°è¦æŠ•ç¨¿
 */
export const usePostPostsIdComments = <TError = ErrorType<ErrorResponse | ErrorResponse | ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPostsIdComments>>, TError,{id: string;data: CreateCommentRequest}, TContext>, request?: SecondParameter<typeof axiosInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postPostsIdComments>>,
        TError,
        {id: string;data: CreateCommentRequest},
        TContext
      > => {

      const mutationOptions = getPostPostsIdCommentsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
